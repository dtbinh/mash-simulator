# mash-simulator network protocol

## Abstract

The MASH platform aims at providing a versatile and powerful testbed
for machine learning with very large sets of feature extractors.

To attain this goal, it was designed as a collection of multiple
inter-communicating servers. The main rationale behind this choice is
to clearly separate the various services and to allow different
implementations running on multiple OS and architectures at multiple
geographic sites. Also, it allows computations to run concurrently
over multiple machines.

This document presents the **Interactive Application Protocol**, used
by the **mash-simulator** application.


## Introduction

All the MASH protocols presented follow these common principles:

- A *Client* sends a *Command* to a *Server*, which reply with a *Response*.

- A *Server* never sends data spontaneously to a *Client*.

- Protocols are **text-based**, but binary data can be enclosed in some *Responses*.

- A *Command* or a *Response* is terminated by a UNIX end-of-line (EOL)
  character.

An exchange (*Command*-*Response*) between a *Client* and a *Server* is of the
following form:

    COMMAND_NAME <param 1> <param 2> ... <param N>
    RESPONSE_1 <value 1> <value 2> ... <value N>
    RESPONSE_2 <value 1> <value 2> ... <value N>
    ...
    RESPONSE_N <value 1> <value 2> ... <value N>


The number of *Responses* sent by the *Server* depends on the
*Command*. There is at least one *Response* for each *Command*.

If the *Command* does not need any specific *Response*, ```OK``` is
returned.

The parameters and values are separated by spaces. String with
spaces are quoted between single-quotes. The character sequence
```\'``` will be interpreted as a single quote, and the sequence
```\n``` will be interpreted as a carriage return.

In case of error, the following *Responses* are returned:

    ERROR <description of the error>

**OR**

    INVALID_ARGUMENTS <received arguments>

which means that an incorrect number of parameters were supplied, or that
the value of one argument isn't valid

**OR**

    UNKNOWN_COMMAND <command>

when the *Client* sent an unknown *Command* to the *Server*


## Common Commands

All the *Servers* must respond to the following *Commands*, even if they
are busy.

### Command: ```STATUS```

*Responses:*

    READY

**OR**

    BUSY

*Description:*

Indicates whether the *Server* can accept commands from the *Client* on this
connection, or if the *Server* is already busy.


### Command: ```INFO```

*Response:*

    TYPE ApplicationServer
    SUBTYPE Interactive
    PROTOCOL <protocol version>

*Description:*

Used to check that the *Client* talks to the correct Server, using the correct
protocol.


### Command: ```DONE```

*Response:*

    GOODBYE

*Description:*

The connection is closed after that.


### Command: ```SLEEP```

*Response:*

    OK

*Description:*

Ask the *Server* not to accept jobs anymore and always respond ```BUSY```
to the ```STATUS``` *Commands*. The *Commands* from the *Clients* currently
connected are still executed.

This *Command* should be used when a *Server* must be stopped for
maintenance, without stopping its current jobs. Once the current
connections are closed, the *Server* can be safely shut down.


### Command: ```LOGS```

*Response:*

    # For each log file
    LOG_FILE <name> <data length>
    <binary data>
    ...
    END_LOGS

*Description:*

Retrieve the log files generated by the *Server* in the current session. Mainly
used for maintenance in case of failure.



## Interactive Application Server Commands

*Protocol version: 1.3*

This section details the protocol used by the Application Servers reporting
a 'Interactive' subtype in their Response to the ```INFO``` *Command* (like the
'3D Simulation Server').

The tasks provided by the *Server* are defined by a *Goal* and an *Environment*.


### Command: ```USE_GLOBAL_SEED```

*Format:*

    USE_GLOBAL_SEED <seed>

*Responses:*

    OK

**OR**

    INVALID_ARGUMENTS <arguments>

**OR**

    GLOBAL_SEED_ALREADY_SET

**OR**

    ERROR <description>

*Description:*

Tell the *Server* about the Global Seed to use. The Global Seed is used to
initialize all the random number generators used by the *Application Server*.

Note that a particular implementation of an *Application Server* might not use any
random number generator.

This *Command* is optional. A global seed is then generated by the *Application
Server* (if one is needed).


### Command: ```LIST_GOALS```

*Response:*

    GOAL <name 1>
    GOAL <name 2>
    ...
    GOAL <name N>
    END_LIST_GOALS

*Description:*

Ask for a list of the goals provided by the *Server*.


### Command: ```LIST_ENVIRONMENTS```

*Format:*

    LIST_ENVIRONMENTS <goal name>

*Response:*

When successful:

    ENVIRONMENT <name 1>
    ENVIRONMENT <name 2>
    ...
    ENVIRONMENT <name N>
    END_LIST_ENVIRONMENTS

Otherwise:

    UNKNOWN_GOAL <goal>

**OR**

    INVALID_ARGUMENTS <arguments>

*Description:*

Ask for a list of the environments provided by the *Server* where the given goal
can be used.


### Command: ```INITIALIZE_TASK```

*Format:*

    INITIALIZE_TASK <task name> <environment name>

*Responses:*

When successful:

    AVAILABLE_ACTIONS <action 1> <action 2> ... <action N>
    AVAILABLE_VIEWS <view 1> <view 2> ... <view N>

Otherwise:

    UNKNOWN_GOAL <goal>

**OR**

    UNKNOWN_ENVIRONMENT <environment>

**OR**

    INVALID_ARGUMENTS <arguments>

**OR**

    ERROR <description>

*Description:*

Notify the *Server* about the task that the *Client* wants to work on. The
*Response* contains:

- all the actions that can be performed on the task
- a description of each available view, in the form <name>:<width>x<height>
  (for example: 'main:320x240')


### Command: ```BEGIN_TASK_SETUP```

*Responses:*

    OK

**OR**

    NO_TASK_SELECTED

**OR**

    ERROR <description>

*Description:*

Tell the *Server* that all the following *Commands* (up until ```END_TASK_SETUP```)
are task-specific settings. See the documentation of the chosen task for more
details.

Note that a task must have been successfully initialized before receiving that
command.


### Command: ```END_TASK_SETUP```

*Responses:*

    OK

**OR**

    ERROR <description>

*Description:*

Terminate the ```TASK_SETUP``` section.


### Command: ```TEACHING```

*Format:*

    TEACHING <ON or OFF>

*Response:*

    OK

**OR**

    NOT_SUPPORTED

**OR**

    NO_TASK_SELECTED

**OR**

    INVALID_ARGUMENTS <arguments>

**OR**

    ERROR <description>

*Description:*

When enabled (```ON```), the *Application Server* might provide "good" actions
as part of the *Responses* to the ```ACTION``` *Commands*. They may be used to
train a predictor. The default is ```OFF```.


### Command: ```RESET_TASK```

*Response:*

When successful:

    STATE_UPDATED

Otherwise:

    NO_TASK_SELECTED

**OR**

    ERROR <description>

*Description:*

Reset the state of the task. The initial state is task-dependent: it can
be something random or always the same thing.


### Command: ```GET_VIEW```

*Format:*

    GET_VIEW <view name>

*Responses:*

When successful:

    VIEW <view name> <MIME type> <image size in bytes>
    <binary data>

Otherwise:

    NO_TASK_SELECTED

**OR**

    INVALID_ARGUMENTS <arguments>

**OR**

    UNKNOWN_VIEW <view>

**OR**

    ERROR <description>

*Description:*

Retrieves one of the views. The *Server* indicates the format of the image by
sending its MIME type as part of the *Response*. The following MIME types are
supported:

- 'image/ppm':  Portable Pixel Map
- 'image/pgm':  Portable Gray Map
- 'image/jpeg': JPEG images
- 'image/png':  PNG images
- 'image/mif':  MASH Image Format (see the dedicated section at the end of
                this document)


### Command: ```ACTION```

*Format:*

    ACTION <action>

*Responses:*

When successful:

    REWARD <reward>
    (optional) EVENT <event>
    (optional) TEACHER_ACTION <action>
    STATE_UPDATED | FINISHED | FAILED

Otherwise:

    NO_TASK_SELECTED

**OR**

    UNKNOWN_ACTION <action>

**OR**

    INVALID_ARGUMENTS <arguments>

**OR**

    ERROR <description>

*Description:*

Perform the given action on the task.

```EVENT``` is an optional part of the *Response*, that contains a human-readable
description of what happened due to the action.

```TEACHER_ACTIOn``` is an optional part of the *Response*, that provides a "good"
action as calculated by the *Application Server*. It may be used to train a
predictor.

```FINISHED``` indicates that the task was successfully solved.

```FAILED``` indicates that it is no more possible to solve the task (it must be
reset before trying again).


### Command: RESET

*Responses:*

    OK

**OR**

    ERROR <description>

*Description:*

Reset the state of the *Application Server*, in order to start a new session (for
instance using another goal and environment).


## Custom file formats

### MASH Image Format

The *MASH Image Format* is a very simple format. The primary goal is to simplify
the implementation of the *Application Servers*, which don't have to rely on an
external library to transmit images to their clients.

The header for version 1 is 8 byte long, composed of the following
*unsigned chars*:

| Offset | Value        | Meaning                       |
|:------:|--------------|-------------------------------|
|      0 | 77           | ASCII code of 'M'             |
|      1 | 73           | ASCII code of 'I'             |
|      2 | 70           | ASCII code of 'F'             |
|      3 | 1            | Version number                |
|      4 | width % 256  | Width least significant byte  |
|      5 | width / 256  | Width most significant byte   |
|      6 | height % 256 | Height least significant byte |
|      7 | height / 256 | Height most significant byte  |

then from 8 to 8 + 3 * width * height, pixels are listed line after
line. Each pixel is defined with 3 bytes to be interpreted as the *RED*,
*GREEN* and *BLUE* components encoded as *unsigned char* (0..255).

Hence, the total byte size of an image in that format is

    8 + 3 * width * height
